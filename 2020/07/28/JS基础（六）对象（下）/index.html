

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>JS基础（六）对象（下） - Hexo</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />

  
  <meta name="keywords" content="zhaoo, hexo-theme-zhaoo,"> 
  
  <meta name="description" content="欢迎阅读，本篇主要介绍JS中的对象。
前言上篇主要学习..."> 
  
  <meta name="author" content="John Doe"> 

  
    <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  
  
    <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  
  
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  
  
    <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_58xq2j9v1id.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css">

  

  <script>
    var CONFIG = window.CONFIG || {}
    CONFIG = {
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        loadingImage: '/images/theme/loading.gif',
      },
      donate_alipay: 'https://pic.izhaoo.com/alipay.jpg',
      donate_wechat: 'https://pic.izhaoo.com/wechat.jpg',
      gitalk: {
        enable: false,
        clientID: '',
        clientSecret: '',
        id: window.location.pathname,
        repo: '',
        owner: '',
        admin: ''
      },
      motto: {
        api: '',
        default: '一个博客'
      },
      galleries: {
        enable: 'true'
      },
      fab: {
        enable: 'true',
        alwaysShow: 'false'
      }
    }
  </script>

  

  
<meta name="generator" content="Hexo 4.2.1"></head>
<body class="lock-screen">
  <div class="loading"></div>
  <nav class="menu">
  <div class="menu-close">
    <i class="iconfont iconplus"></i>
  </div>
  <ul class="menu-content">
    
    
    
    
    <li class="menu-item"><a href="/ "> 首页</a></li>
    
    
    
    
    <li class="menu-item"><a href="/galleries "> 摄影</a></li>
    
    
    
    
    <li class="menu-item"><a href="/archives "> 归档</a></li>
    
    
    
    
    <li class="menu-item"><a href="/tags "> 标签</a></li>
    
    
    
    
    <li class="menu-item"><a href="/categories "> 分类</a></li>
    
    
    
    
    <li class="menu-item"><a href="/about "> 关于</a></li>
    
  </ul>
  <div class="menu-copyright"><p>Copyright© 2020 | by lilith</p></div>
</nav>
  <main id="main">
  <div class="container" id="container">
    <article class="article">
  <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">JS基础（六）对象（下）</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>2020-07-28</span
        class="post-info-item">
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>6888</span>
    </div>
  </div>
</section>
  <section class="main">
    <section class="content">
      <p>欢迎阅读，本篇主要介绍JS中的对象。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇主要学习对象概念内容，本篇学习对象的属性方法、数组、对象的复制、遍历等。</p>
<p>上篇中提到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myObj = &#123;<br>  a: 2<br>&#125;<br><br>myObj.a; // 2 <br>myObj[<span class="hljs-string">"a"</span>]; // 2<br></code></pre></td></tr></table></figure>
<p>对象的两种访问方式，.a被称为“属性访问”，[‘a’]被称为“键访问”，我们通常采用“属性访问”的方式。</p>
<h2 id="1-属性与方法"><a href="#1-属性与方法" class="headerlink" title="1. 属性与方法"></a>1. 属性与方法</h2><p>思考一下，如果访问的属性是一个函数，由于函数容易被认为是属于某个对象的，在其他语言中，属于某个对象（也被称为类）的函数通常被成为“方法”，但从技术角度来讲，函数永远不会“属于”一个对象。不过，有些函数具有this引用，有时候这些this确实会指向调用位置的对象引用。但这种用法从本质上来说并没有把一个函数变成一个“方法”，因为this是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多算是间接关系。<br>无论返回值是什么类型，每次访问对象的属性就是属性访问。如果属性访问返回的是一个函数，那它也并不是一个“方法”。属性访问返回的函数和其他函数没有任何区别（除了可能发生隐式绑定this）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span> () &#123;<br>  console.log(<span class="hljs-string">"foo"</span>);<br>&#125;<br><br>var someFoo = foo; // 对foo的变量引用<br>var myObj = &#123;<br>  someFoo: foo<br>&#125;;<br><br>foo; // <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span>() &#123;...&#125;<br>someFoo; // <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span>() &#123;...&#125;<br>myObj.someFoo(); // <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">foo</span></span>() &#123;...&#125;<br></code></pre></td></tr></table></figure>
<p>someFoo和myObj.someFoo只是对于同一个函数的不同引用，并不能说明这个函数是特别的或者“属于”某个对象。如果foo()定义时内部有一个this引用，那这两个函数引用的唯一区别就是myObj.someFoo中的this会被隐式绑定到一个对象。无论哪种引用形式都不能称之为“方法”。</p>
<h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2 数组"></a>2 数组</h2><p>数组也支持[]访问，不过数组有一套更加结构化的值存储机制，数组期望的下标是非负整数。数组也是对象，所以虽然每个下标都是整数，你仍可给数组添加属性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myArray = [<span class="hljs-string">"foo"</span>, 42, <span class="hljs-string">"bar"</span>];<br>myArray.baz = <span class="hljs-string">"baz"</span>;<br>myArray.length; // 3<br>myArray.baz; // <span class="hljs-string">"baz"</span><br></code></pre></td></tr></table></figure>
<p>虽然我们添加了命名属性，数组的length值并未发生变化。我们完全可以把数组当作一个普通键/值对象来用，并且不添加任何数值索引，但这并不是一个好主意，数组和普通对象都是根据其对应的行为和用途进行了优化的，所以最好用对象存储键/值对，用数组存储下标/值对。</p>
<p>需注意：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myArray = [<span class="hljs-string">"foo"</span>, 42, <span class="hljs-string">"bar"</span>];<br>myArray[<span class="hljs-string">"3"</span>] = <span class="hljs-string">"baz"</span>;<br>myArray.length; // 4<br>myArray[3]; // baz<br></code></pre></td></tr></table></figure>
<p>当你试图向数组添加一个属性，但是属性名“看起来”像一个数字，那它会变成一个数值下标，因此会修改数组的内容，而不是添加一个新属性。</p>
<h2 id="3-复制对象"><a href="#3-复制对象" class="headerlink" title="3 复制对象"></a>3 复制对象</h2><p>怎样复制一个对象呢？或许这比我们想象中的要复杂：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">var anotherObj = &#123;<br>  c: <span class="hljs-literal">true</span>,<br>&#125;<br><br>var anotherArray = [];<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">anotherFunction</span></span>() &#123;...&#125;;<br><br>var myObj = &#123;<br>  a: 2,<br>  b: anotherObj, // 引用，不是复本！<br>  c: anotherArray, // 另一个引用<br>  d: anotherFunction,<br>&#125;<br><br>anotherArray.push(anotherObj, myObj);<br></code></pre></td></tr></table></figure>

<p>如何准确的表示myObj的复制呢？<br>首先我们需要判断它是深拷贝还是浅拷贝。对于浅拷贝来说，复制出的新对象中 a 的值会复制旧对象中 a 的值，也就是2。但是新对象中 b、c、d三个属性其实只是三个引用，它们和旧对象中引用的对象是一样的。<br>对于深拷贝来说，除了复制myObj以外还会复制 anotherObj 和 anotherArray，那么问题就来了，anotherArray 引用了 anotherObj 和 myObj，所以又要复制 myObj，这样就会由于循环引用导致死循环。除此之外，我们还不确定“复制”一个函数意味着什么。</p>
<p>那么如何解决这些棘手的问题呢？</p>
<p>对于JSON安全的对象（也就是说可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象）来说，有一种巧妙的复制方式：<br>var myObj = JSON.parse(JSON.stringify(someObj)); // 这种方法需要保证对象是JSON安全的，所以只能适用于部分情况</p>
<p>相比深复制，浅复制更易懂，且问题要少的多，所以ES6新增<code>Object.assign(...)</code>方法来实现浅复制。<br><code>Object.assign(...)</code> 第一个参数是目标对象，之后还可以跟一个或多个对象。它会遍历一个或多个源对象的所有可枚举的自有键，并把它们复制（通过 <code>=</code> 操作符）到目标对象，最后返回目标对象，就像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">var newObj = Object.assign(&#123;&#125;, myObj);<br><br>newObj.a; // 2<br>newObj.b = anotherObj; // <span class="hljs-literal">true</span><br>newObj.c = anotherArray, // <span class="hljs-literal">true</span><br>newObj.d = anotherFunction, // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<p>由于Object.assign就是使用 <code>=</code> 操作符来赋值，所以源对象属性的一些特性（如writable）不会被复制到复制对象中。</p>
<h2 id="4-属性描述符"><a href="#4-属性描述符" class="headerlink" title="4 属性描述符"></a>4 属性描述符</h2><p>在ES5之前，JS语言本身并没有提供可以直接检测属性特性的方法，比如判断属性是否只读。从ES5开始所有属性都具备了属性描述符。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myObj = &#123;<br>  a: 2,<br>&#125;<br><br>Object.getOwnPropertyDescriptor(myObj, <span class="hljs-string">"a"</span>);<br>// &#123;<br>//  value: 2,<br>//  writable: <span class="hljs-literal">true</span>, // 可写<br>//  enumerable: <span class="hljs-literal">true</span>, // 可枚举<br>//  configurable: <span class="hljs-literal">true</span>, // 可配置<br>// &#125;<br></code></pre></td></tr></table></figure>
<p>如你所见，这个普通的对象属性对应的属性描述符（数据描述符）除了2，还包含三个特性：writable（可写）、enumerable（可枚举）、configurable（可配置）。在创建普通属性时，属性描述符会使用默认值，可以使用Object.defineProperty(…)来添加一个新属性或者修改一个已有属性（如果它是configurable）并对特性进行设置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myObj = &#123;&#125;;<br>Object.defineProperty(myObj, <span class="hljs-string">"a"</span>, &#123;<br>  value: 2,<br>  wirtable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">true</span>,<br>  enumerable: <span class="hljs-literal">true</span>,<br>&#125;);<br>myObj.a; // 2<br></code></pre></td></tr></table></figure>
<p>我们使用 <code>defineProperty(...)</code> 给 <code>myObj</code> 添加一个普通的属性并显示指定了一些特性，但一般来说不会用到这种方式，除非你想修改属性描述符。</p>
<h6 id="4-1-wirtable"><a href="#4-1-wirtable" class="headerlink" title="4.1 wirtable"></a>4.1 wirtable</h6><p>特性 <code>wirtable</code> 决定是否可以修改属性的值。如果将 <code>wirtable</code> 的值设为 <code>false</code>，我们再去修改属性值时会失败，需要注意，严格模式下，会报错：TypeError。</p>
<h6 id="4-2-configurable"><a href="#4-2-configurable" class="headerlink" title="4.2 configurable"></a>4.2 configurable</h6><p>属性是否可配置，只要 <code>configurable: true</code> 就可以使用 <code>defineProperty(...)</code> 方法修改属性描述符，属性设置为不可配置，再去修改属性描述符不管是否在严格模式下，都会报 <code>TypeError</code> 错误。把 <code>configurable</code> 修改成 <code>false</code> 是单向的，无法撤销。<br>注意一个小小的例外：即使 <code>configurable:false</code>，我们还是可以把 <code>writable</code> 的状态由 <code>true</code> 变成 <code>false</code>，但无法从 <code>false</code> 变成 <code>true</code>。<br>另外，除了无法修改，<code>configurable: true</code> 还会禁止删除这个属性。</p>
<h6 id="4-3-enumerable"><a href="#4-3-enumerable" class="headerlink" title="4.3 enumerable"></a>4.3 enumerable</h6><p>这个描述符控制的是属性是否会出现在对象的属性枚举中，比如 <code>for..in</code> 循环。如果把 <code>enumerable</code> 设为 <code>false</code>，这个属性就不会出现在枚举中，虽然仍可以正常访问它。我们一版定义的普通属性默认值都是 <code>true</code>，也是最常用的。</p>
<h2 id="5-不变性"><a href="#5-不变性" class="headerlink" title="5 不变性"></a>5 不变性</h2><p>有时候我们希望属性或对象是不可改变的，首先我们要知道很重要的一点：所有的方法创建的都是浅不变性，既它们只会影响目标对象和它的直接属性。如果目标对象引用了其他对象（数组、对象、函数等），其他对象的内容不受影响，仍是可变的。</p>
<h6 id="5-1-对象常量"><a href="#5-1-对象常量" class="headerlink" title="5.1 对象常量"></a>5.1 对象常量</h6><p>结合 <code>writable:false</code> 和 <code>configurable:false</code> 就可以创建一个真正的常量属性（不可修改、重定义、删除）</p>
<h5 id="5-2-禁止扩展"><a href="#5-2-禁止扩展" class="headerlink" title="5.2 禁止扩展"></a>5.2 禁止扩展</h5><p>如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 <code>Object.preventExtensions(..)</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myObj = &#123;<br>  a: 2,<br>&#125;<br>Object.preventExtensions(myObj);<br>myObj.b = 3;<br>myObj.b; // undefined<br></code></pre></td></tr></table></figure>
<h5 id="5-3-密封"><a href="#5-3-密封" class="headerlink" title="5.3 密封"></a>5.3 密封</h5><p><code>Object.seal(..)</code> 会创建一个“密封”对象，这个方法实际上会在一个现有对象上调用 <code>Object.preventExtensions(..)</code>，并把所有属性标记 <code>configurable: false</code>。所以“密封”之后不仅不能添加新属性，也不能重新配置或者删除任何已有属性（虽然可以修改属性的值）。</p>
<h5 id="5-4-冻结"><a href="#5-4-冻结" class="headerlink" title="5.4 冻结"></a>5.4 冻结</h5><p><code>Object.freeze(..)</code> 会创建一个“冻结”对象，这个方法实际上在现有对象上调用 <code>Object.seal(..)</code> 方法，并把所有“数据访问”属性标记为 <code>writable:false</code>，这样就无法修改他们的值。这个方法是可以应用在对象上最高级别的不可变性，它会禁止对于对象本身及其任意直接属性的修改（不过，这个对象引用的其他对象是不受影响的）。</p>
<h2 id="6-存在性"><a href="#6-存在性" class="headerlink" title="6 存在性"></a>6 存在性</h2><p>先看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myObj = &#123;<br>  a: undefined,<br>&#125;<br>myObj.a; // undefined<br>myObj.b; // undefined<br></code></pre></td></tr></table></figure>
<p>如你所见，这两种情况都返回 <code>undefined</code>，那我们如何区分呢？<br>我们可以在不访问属性值的情况下判断对象中是否存在这个属性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myObj = &#123;<br>  a: 2,<br>&#125;<br>(<span class="hljs-string">"a"</span> <span class="hljs-keyword">in</span> myObj); // <span class="hljs-literal">true</span><br>(<span class="hljs-string">"b"</span> <span class="hljs-keyword">in</span> myObj); // <span class="hljs-literal">false</span><br><br>myObj.hasOwnProperty(<span class="hljs-string">"a"</span>); // <span class="hljs-literal">true</span><br>myObj.hasOwnProperty(<span class="hljs-string">"b"</span>); // <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>
<p><code>in</code> 操作符会检查属性是否在对象及其 [[Protptype]] 原型链中，相比之下，<code>hasOwnProperty(..)</code> 只会检查属性是否存在 <code>myObj</code> 对象中，不会检查 <code>[[Protptype]]</code> 原型链。<br>看起来 <code>in</code> 操作符可以检查容器内是否有某个值，但是它实际上检查的是某个属性名是否存在。对于数组来说这个区别很重要，<code>4 in [2, 4, 6]</code> 的结果不是我们期待的 <code>true</code>，因为 <code>[2, 4, 6]</code> 这个数组中包含的属性名是 <code>0、1、2</code>，并没有 <code>4</code>。</p>
<h5 id="6-1-枚举"><a href="#6-1-枚举" class="headerlink" title="6.1 枚举"></a>6.1 枚举</h5><p>接下来详细介绍下枚举。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myObj = &#123;&#125;;<br>Object.defineProperty(<br>  myObj,<br>  <span class="hljs-string">"a"</span>,<br>  // 让a像普通属性一样可枚举<br>  &#123; enumerable: <span class="hljs-literal">true</span>, value: 2 &#125;<br>);<br><br>Object.defineProperty(<br>  myObj,<br>  <span class="hljs-string">"b"</span>,<br>  // 让b不可枚举<br>  &#123; enumerable: <span class="hljs-literal">false</span>, value: 3 &#125;<br>);<br><br>myObj.b; // 3<br>(<span class="hljs-string">"b"</span> <span class="hljs-keyword">in</span> myObj); // <span class="hljs-literal">true</span><br>myObj.hasOwnProperty(<span class="hljs-string">"b"</span>); // <span class="hljs-literal">true</span><br><br><span class="hljs-keyword">for</span> (var k <span class="hljs-keyword">in</span> myObj) &#123;<br>  console.log(k, myObj[k]);<br>&#125; // <span class="hljs-string">"a"</span> 2<br></code></pre></td></tr></table></figure>
<p>可以看到 <code>myObj.b</code> 确实存在并且有访问值，但却不会出现在 <code>for ... in</code> 循环中（尽管可以通过 <code>in</code> 操作符来判断是否存在）；原因是：“可枚举”就相当于“可以出现在对象属性的遍历中”。</p>
<p>也可以通过另一种方式来区分属性是否可枚举：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myObj = &#123;&#125;;<br>Object.defineProperty(<br>  myObj,<br>  <span class="hljs-string">"a"</span>,<br>  // 让a像普通属性一样可枚举<br>  &#123; enumerable: <span class="hljs-literal">true</span>, value: 2 &#125;<br>);<br><br>Object.defineProperty(<br>  myObj,<br>  <span class="hljs-string">"b"</span>,<br>  // 让b不可枚举<br>  &#123; enumerable: <span class="hljs-literal">false</span>, value: 3 &#125;<br>);<br><br>myObj.propertyIsEnumerable(<span class="hljs-string">"a"</span>); // <span class="hljs-literal">true</span><br>myObj.propertyIsEnumerable(<span class="hljs-string">"b"</span>); // <span class="hljs-literal">false</span><br><br>Object.keys(myObj); // [<span class="hljs-string">"a"</span>]<br>Object.getOwnPropertyNames(myObj); // [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>]<br></code></pre></td></tr></table></figure>
<p><code>getOwnPropertyNames(..)</code> 会检查给定的属性名是否直接存在在对象中（而不是在原型链上）并且满足 <code>enumerable: true</code>。<br><code>Object.keys(..)</code> 会返回一个数组，包含所有可枚举的属性，<code>Object.getOwnPropertyNames(..)</code> 会返回一个数组，包含所有属性，无论他们是否可枚举。<br><code>in</code> 和 <code>hasOwnProperty(..)</code> 的区别在于是否查找 [[Protptype]] 原型链，然而，<code>Object.keys</code> 和 <code>Object.getOwnPropertyNames</code> 都只会查找对象直接包含的属性。</p>
<h2 id="9-遍历"><a href="#9-遍历" class="headerlink" title="9 遍历"></a>9 遍历</h2><p><code>for..in</code> 循环可以用来遍历对象的可枚举属性列表（包括 <code>[[Protptype]]</code> 原型链）。但是如何遍历属性的值呢？<br>对于数值索引的数组来说，可以使用标准化的for循环来遍历值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myArr = [1, 2, 3];<br><span class="hljs-keyword">for</span> (var i = 0; i &lt; myArr.length; i++) &#123;<br>  console.log(myArr[i]);<br>&#125; // 1 2 3<br></code></pre></td></tr></table></figure>
<p>这实际上并不是在遍历值，而是遍历下标来指向值，如myArr[i]。<br>ES5中增加了一些数组的辅助迭代器，包括 <code>forEach(..)</code>、<code>every(..)</code>、<code>some(..)</code>。每种辅助迭代器中都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是它们对于回调函数返回值的处理方式不同。<br><code>forEach(..)</code> 会遍历数组中的所有值并忽略回调函数的返回值。<code>every(..)</code> 会一直运行直到回调函数返回 <code>false</code>。<code>some(..)</code> 会一直运行直到回调函数返回 <code>true</code>。<br>使用 <code>for..in</code> 循环遍历对象是无法获取属性值的，因为它们实际上遍历的是对象中所有可枚举属性，你需要手动获取属性值。那么如何直接遍历值，而不是数组下标或对象属性呢？ES6增加了一种用来遍历数组的 <code>for..of</code> 循环语法（如果对象本身定义了迭代器的话也可以遍历对象）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">var myArr = [1, 2, 3];<br><span class="hljs-keyword">for</span> (var v of myArr) &#123;<br>  console.log(v);<br>&#125;<br>// 1<br>// 2<br>// 3<br></code></pre></td></tr></table></figure>
<p>下篇：混合对象 “类”</p>

    </section>
    <section class="extra">
      
        <section class="donate">
  <!-- <div class="qrcode">
    <img   class="lazyload" data-original="< %- theme.donate.alipay " src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div> -->
  <!-- <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div> -->
</section>
      
      
      
<nav class="nav">
  
  
    <a href="/2020/07/26/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/">JS基础（六）对象（上）<i class="iconfont iconright"></i></a>
  
</nav>

    </section>
    
  </section>
</article>
  </div>
</main>
  <footer class="footer">
  <div class="footer-social">
    
    
    
    
    
    <a href="https://github.com/wang123screet " target="_blank" onMouseOver="this.style.color= '#24292E'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  icongithub-fill "></i>
    </a>
    
    
    
    
    
    <a href="1362916323@qq.com " target="_blank" onMouseOver="this.style.color='#FFBE5B'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconmail"></i>
    </a>
    
  </div>
  <div class="footer-copyright"><p>Copyright© 2020 | by lilith</p></div>
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  <div class="fab fab-menu">
    <i class="iconfont iconmenu"></i>
  </div>
  
</body>


<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>






<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>








<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>






<script src="https://cdn.bootcdn.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js"></script>






<script src="/js/script.js"></script>



<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>











</html>